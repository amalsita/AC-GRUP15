# -*- coding: utf-8 -*-
"""AC-GRUP15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I8k9IK53wlAbmrZ6AKE54kA9jlmN9Q6L

# MENTAL HEALTH CLUSTERING

fer dos clusters finals
- treballadors que treballen en un ambient saludable i els que no

## Imports
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
pd.set_option('display.float_format', lambda x: '%.2f' % x)
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import confusion_matrix,f1_score
from sklearn.metrics import classification_report
from sklearn.model_selection import validation_curve

from google.colab import drive
drive.mount('/content/drive')

"""## Importació Dataset"""

mental_health_dataset = pd.read_csv("/content/drive/MyDrive/4T ED/Aprenentatge computacional /survey.csv")
orig_mental_health_dataset = mental_health_dataset.copy()
orig_mental_health_dataset.head()

"""------"""





"""Aquesta funció té la finalitat d'entendre les característiques i composició del conjunt de dades."""

def understand_variables(dataset):
    print("Type = " +str(type(dataset))+"\n")
    print("Shape = "+str(dataset.shape)+"\n")
    print("Head : \n\n"+str(dataset.head())+"\n\n")
    print(str(dataset.info())+"\n\n")
    print("No.of unique values :\n\n"+str(dataset.nunique(axis=0))+"\n\n")
    print("Description :\n\n"+str(dataset.describe())+"\n\n")

    #print(dataset.describe(exclude=[np.number]))
    #Since no categorical variables, no need to have the above line

    print("Null count :\n\n"+str(dataset.isnull().sum()))

understand_variables(mental_health_dataset)



def understand_dist(dataset,feature_type):

    if feature_type == "Categorical":

        categorical_features=[feature for feature in dataset.columns if dataset[feature].dtype=='O']
        dataframes=[]
        for feature in categorical_features:
            dataframe=dataset[feature].value_counts().rename_axis(feature).reset_index(name='counts')
            dataframes.append(dataframe)

            plt.figure(figsize=(10,8))
            sns.countplot(y=feature,data = dataset)
            plt.show()
            print(dataframe,'\n')

        #for i in range(len(dataframes)):
        #    print(dataframes[i],'\n')

    elif feature_type == "Numeric":

        numerical_features=[feature for feature in dataset.columns if dataset[feature].dtype!='O']

        for feature in numerical_features:
            plt.figure(figsize=(10,4))
            sns.distplot(dataset[feature])
            plt.show()

            print("Description :\n\n"+str(dataset[feature].describe())+"\n\n")

understand_dist(mental_health_dataset.drop(["Timestamp"],axis=1),"Categorical")  #genera las gráficas sobre nuestras características categoricas  dataset

understand_dist(mental_health_dataset,"Numeric") #crea las gráficas de los datos numericos de nuestro dataset

mental_health_dataset = mental_health_dataset

"""#en self_employed hi ha NaNs, s'ha de tractar i posar com a None"""

mental_health_dataset.loc[mental_health_dataset.self_employed.isnull(),'self_employed'] = mental_health_dataset.self_employed.mode().iloc[0]
mental_health_dataset.loc[mental_health_dataset.work_interfere.isnull(),'work_interfere'] = mental_health_dataset.work_interfere.mode().iloc[0]

print("Null count :\n\n"+str(mental_health_dataset.isnull().sum()))

#solucionamos problemas con el campoo gender ( clasificamos en: male, female, LGBTQ)
gender_dict_map = {'Male':'Male','male':'Male','male ':'Male','Female':'Female','M':'Male','female':'Female','F':'Female','m':'Male','f':'Female',
                   'Make':'Male','Woman':'Female','Male ':'Male','Female ':'Female','Man':'Male','Female (trans)':'LGBTQ','Cis Male':'Male','Male-ish':'LGBTQ','p':'LGBTQ','femail':'Female',
                   'woman':'Female','Agender':'LGBTQ','Cis Female':'Female','Guy (-ish) ^_^':'LGBTQ','Malr':'Male','Trans woman':'LGBTQ','Mail':'Male','fluid':'LGBTQ','Cis Man':'Male',
                   'Female (cis)':'Female','cis male':'Male','male leaning androgynous':'LGBTQ','queer':'LGBTQ','A little about you':'LGBTQ','Androgyne':'LGBTQ','non-binary':'LGBTQ',
                   'Trans-female':'LGBTQ','something kinda male?':'LGBTQ','Male (CIS)':'Male','queer/she/they':'LGBTQ','Genderqueer':'LGBTQ','ostensibly male, unsure what that really means':'LGBTQ',
                   'cis-female/femme':'Female','maile':'Male','All':'LGBTQ','Mal':'Male','Femake':'Female','Neuter':'LGBTQ','Nah':'LGBTQ','Enby':'LGBTQ','msle':'Male'}

mental_health_dataset.Gender = mental_health_dataset.Gender.map(gender_dict_map)

#mirar si hay valores unicos de genero
orig_mental_health_dataset.loc[mental_health_dataset.Gender[mental_health_dataset.Gender.isnull()].index].Gender.unique()

#miramos dataset actualizado
mental_health_dataset.head(20)

# necesitamos que las edades esten entre 18 y 72 ambos incluidos

mental_health_dataset.loc[mental_health_dataset.Age<18,'Age']=18
mental_health_dataset.loc[mental_health_dataset.Age>70,'Age']=72

mental_health_true_age = mental_health_dataset.Age
display(mental_health_true_age)

# Converting categorical variables to numeric represtation

mental_health_dataset = pd.get_dummies(mental_health_dataset)
display(mental_health_dataset)

# understand_dist(mental_health_dataset,"Categorical")
# understand_dist(mental_health_dataset,"Numeric")

"""# CLUSTERING"""

#comprovem encara que ja sabem que han de ser 2 cluster --> comprovació amb elbow --> per cada model

"""## K MEANS"""

# Standard scaling (Usually from 0 to 1) is mandatory for a clustering problem
import pandas as pd
from sklearn.preprocessing import MinMaxScaler


if 'Cluster_no' in mental_health_dataset.columns:
    mental_health_dataset = mental_health_dataset.drop('Cluster_no', axis=1)
scaler = MinMaxScaler()
mental_health_dataset = pd.DataFrame(scaler.fit_transform(mental_health_dataset),columns=mental_health_dataset.columns)

# For now, we are interested in only 2 clusters

from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=2, max_iter=600, algorithm = 'auto',random_state=1)
kmeans = kmeans.fit(mental_health_dataset.drop(['Age'],axis=1))

cluster = []

for x in range(len(mental_health_dataset)):
    predict_me = np.array(mental_health_dataset.drop(['Age'],axis=1).iloc[x].astype(float))
    predict_me = predict_me.reshape(-1, len(predict_me))
    cluster.append(kmeans.predict(predict_me)[0])

mental_health_dataset = pd.concat([mental_health_dataset,pd.Series(cluster,name='Cluster_no')],axis=1)

mental_health_dataset.Age = mental_health_true_age

cluster_1 = mental_health_dataset[mental_health_dataset.Cluster_no==0]
cluster_2 = mental_health_dataset[mental_health_dataset.Cluster_no==1]


with pd.option_context('display.max_rows', None, 'display.max_columns', None):

    # We use mean to calculate % of employees who answered the index value
    cluster_compare = pd.concat([cluster_1.mean(),cluster_2.mean()],axis=1)
    cluster_compare.columns=['0','1']
    cluster_compare = cluster_compare.drop('Cluster_no')
    for index,row in cluster_compare.iterrows():
        if index!="Age":
            row['0']=row['0']*100
            row['1']=row['1']*100
    cluster_compare['Diff'] = (cluster_compare['0']-cluster_compare['1'])
    cluster_compare['Abs Diff'] = np.abs(cluster_compare['0']-cluster_compare['1'])
    cluster_compare=cluster_compare.sort_values(by='Abs Diff',ascending=False)
    print(cluster_compare)


with pd.option_context('display.max_rows', None, 'display.max_columns', None):  # more options can be specified also
    cluster_compare = pd.concat([cluster_1.mean(),cluster_2.mean()],axis=1)
    cluster_compare.columns=['0','1']
    cluster_compare = cluster_compare.drop('Cluster_no')
    for index,row in cluster_compare.iterrows():
        if index!="Age":
            row['0']=row['0']*100
            row['1']=row['1']*100
    cluster_compare['Diff'] = (cluster_compare['0']-cluster_compare['1'])
    cluster_compare['Abs Diff'] = np.abs(cluster_compare['0']-cluster_compare['1'])
    print(cluster_compare)

# PCA conversion to plot clusters succesfully in 2D

from sklearn.decomposition import PCA
reduced_data = PCA(n_components=2).fit_transform(mental_health_dataset)
results = pd.DataFrame(reduced_data,columns=['pca1','pca2'])

plt.figure(figsize=(10,4))
sns.scatterplot(x="pca1", y="pca2", hue=mental_health_dataset['Cluster_no'], data=results)
plt.title("Employee's workspace Mental Health Attitude clustering")
plt.show()

from yellowbrick.cluster import KElbowVisualizer
visualizer = KElbowVisualizer(kmeans, k=(2,14))
visualizer.fit(mental_health_dataset)

"""con kmeans va bien pero no los acaba de separar bien del todo, en cambio en gaussian si"""



"""- Provar diferents tipus d'algoritmes:

El tipo de algoritmo de clustering más adecuado para tu conjunto de datos dependerá de diversos factores, como la distribución de los datos, la dimensionalidad y la naturaleza de las relaciones entre las variables. Aquí te doy algunas sugerencias de algoritmos de clustering que podrían funcionar bien con tu conjunto de datos:

K-Means:
Este es uno de los algoritmos de clustering más comunes. Es eficiente y fácil de entender. Puede ser útil para identificar grupos de individuos con características similares, por ejemplo, en términos de edad, género, y otros factores.

DBSCAN (Density-Based Spatial Clustering of Applications with Noise):
DBSCAN es bueno para identificar grupos con formas más complejas y es resistente al ruido. Puede ser útil si hay densidades variables en diferentes regiones del espacio.

Hierarchical Clustering:
Este método construye una jerarquía de grupos y puede ser útil si existe una estructura jerárquica en tus datos. Puede proporcionar una visión más detallada de cómo se agrupan los datos a diferentes niveles.

Gaussian Mixture Model (GMM):
GMM asume que los datos están generados por un conjunto de distribuciones gaussianas. Es útil cuando los grupos en tus datos pueden tener formas más complejas y superposiciones.

Mean Shift:
Mean Shift es adecuado para datos con formas irregulares y no paramétricas. Encuentra los modos de densidad en los datos, lo que puede ser útil si hay regiones de alta densidad en tus datos.

Clustering Espectral:
Este método es eficaz para identificar agrupaciones en datos no lineales y puede ser útil si hay relaciones no lineales en tu conjunto de datos.

Antes de aplicar estos algoritmos, es importante preprocesar tus datos para manejar valores atípicos, normalizar características y manejar datos categóricos como el género y el país adecuadamente (por ejemplo, mediante codificación one-hot).
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.mixture import GaussianMixture
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns


if 'Cluster_no' in mental_health_dataset.columns:
    mental_health_dataset = mental_health_dataset.drop('Cluster_no', axis=1)
# Standard scaling (Usually from 0 to 1) is mandatory for a clustering problem
scaler = MinMaxScaler()
mental_health_dataset = pd.DataFrame(scaler.fit_transform(mental_health_dataset), columns=mental_health_dataset.columns)



# Use Gaussian Mixture Model
gmm = GaussianMixture(n_components=2, random_state=1)
gmm.fit(mental_health_dataset.drop(['Age'], axis=1))

# Predict clusters
cluster = gmm.predict(mental_health_dataset.drop(['Age'], axis=1))
display(cluster)
mental_health_dataset = pd.concat([mental_health_dataset, pd.Series(cluster, name='Cluster_no')], axis=1)
display("hola",mental_health_dataset)
mental_health_dataset.Age = mental_health_true_age



display("hola",mental_health_dataset)

cluster_1 = mental_health_dataset[mental_health_dataset.Cluster_no == 0]
cluster_2 = mental_health_dataset[mental_health_dataset.Cluster_no == 1]

# Display cluster comparison
with pd.option_context('display.max_rows', None, 'display.max_columns', None):
    cluster_compare = pd.concat([cluster_1.mean(), cluster_2.mean()], axis=1)
    cluster_compare.columns = ['0', '1']
    cluster_compare = cluster_compare.drop('Cluster_no')
    for index, row in cluster_compare.iterrows():
        if index != "Age":
            row['0'] = row['0'] * 100
            row['1'] = row['1'] * 100
    cluster_compare['Diff'] = (cluster_compare['0'] - cluster_compare['1'])
    cluster_compare['Abs Diff'] = np.abs(cluster_compare['0'] - cluster_compare['1'])
    cluster_compare = cluster_compare.sort_values(by='Abs Diff', ascending=False)
    print(cluster_compare)

# Plot clusters using PCA
reduced_data = PCA(n_components=2).fit_transform(mental_health_dataset.drop(['Age'], axis=1))
results = pd.DataFrame(reduced_data, columns=['pca1', 'pca2'])

plt.figure(figsize=(10, 4))
sns.scatterplot(x="pca1", y="pca2", hue=mental_health_dataset['Cluster_no'], data=results)
plt.title("Employee's workspace Mental Health Attitude clustering")
plt.show()

"""podem veure que en el cluster 1 tenen idees una mica dispereses i diferents i no hi ha tants tampoc, en canvi hi ha més empleats ene l cluster 0 i tenen les idees molt semblants, això si son dos clsuters ben separats això vol dir que uns 100% es preocupen per la slaut mental i els altres 100% no els importa.

KMEANS:

GAUSSIAN:
MinMaxScaler: El escalamiento es importante en problemas de agrupamiento (clustering) para asegurarse de que todas las características tengan la misma escala.
Gaussain (2 componentes): usamos el gaussian mixture para clasificar. Luego guardamos para cada empleado al cluster que forma parte
SEguidamente hace un análisis comparativo entre los dos clusters:
- hacemos la media de cada cluster y la pasamos a porcentaje lo guardamos en un nuevo dataset
- hacemos otra columnna con la diferencia de las dos medias de los clusters
- y otra columnas con la diferencia absoluta --> ordenadmos el dataset segun esta ultima columa

Por último usamos PCA para reeducir la dimensionalidad y mostramos en un scatterplot la tendencia de los trabajadores por cluster.
Usamos PCA porque es mucho más util a la hora de visualizar reducimos para que se nos quede el escenario con dos dimensiones

CLUSTER 0: TIENEN EN CUENTA LA SALUD MENTAL
CLUSTER 1: NO TIENEN EN CUENTA LA SALUD MENTAL
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import DBSCAN
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns

# Verificar y eliminar la columna 'Cluster_no' si ya existe
if 'Cluster_no' in mental_health_dataset.columns:
    mental_health_dataset = mental_health_dataset.drop('Cluster_no', axis=1)

# Standard scaling (Usually from 0 to 1) is mandatory for a clustering problem
scaler = MinMaxScaler()
mental_health_dataset = pd.DataFrame(scaler.fit_transform(mental_health_dataset), columns=mental_health_dataset.columns)

# Use DBSCAN
dbscan = DBSCAN(eps=0.3, min_samples=5)  # Puedes ajustar eps y min_samples según tu necesidad
cluster = dbscan.fit_predict(mental_health_dataset.drop(['Age'], axis=1))
mental_health_dataset = pd.concat([mental_health_dataset, pd.Series(cluster, name='Cluster_no')], axis=1)
mental_health_dataset.Age = mental_health_true_age

# Filtrar datos por clusters asignados por DBSCAN
cluster_1 = mental_health_dataset[mental_health_dataset.Cluster_no == 0]
cluster_2 = mental_health_dataset[mental_health_dataset.Cluster_no == 1]

# Display cluster comparison
with pd.option_context('display.max_rows', None, 'display.max_columns', None):
    cluster_compare = pd.concat([cluster_1.mean(), cluster_2.mean()], axis=1)
    cluster_compare.columns = ['0', '1']
    cluster_compare = cluster_compare.drop('Cluster_no')
    for index, row in cluster_compare.iterrows():
        if index != "Age":
            row['0'] = row['0'] * 100
            row['1'] = row['1'] * 100
    cluster_compare['Diff'] = (cluster_compare['0'] - cluster_compare['1'])
    cluster_compare['Abs Diff'] = np.abs(cluster_compare['0'] - cluster_compare['1'])
    cluster_compare = cluster_compare.sort_values(by='Abs Diff', ascending=False)
    print(cluster_compare)

# Plot clusters using PCA
reduced_data = PCA(n_components=2).fit_transform(mental_health_dataset.drop(['Age'], axis=1))
results = pd.DataFrame(reduced_data, columns=['pca1', 'pca2'])

plt.figure(figsize=(10, 4))
sns.scatterplot(x="pca1", y="pca2", hue=mental_health_dataset['Cluster_no'], data=results)
plt.title("Employee's workspace Mental Health Attitude clustering")
plt.show()

"""Sensibilidad a la densidad en cambio kmeans y gaussian son más robustos"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import MeanShift
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import seaborn as sns

# Verificar y eliminar la columna 'Cluster_no' si ya existe
if 'Cluster_no' in mental_health_dataset.columns:
    mental_health_dataset = mental_health_dataset.drop('Cluster_no', axis=1)

# Standard scaling (Usually from 0 to 1) is mandatory for a clustering problem
scaler = MinMaxScaler()
mental_health_dataset = pd.DataFrame(scaler.fit_transform(mental_health_dataset), columns=mental_health_dataset.columns)

# Use Mean Shift
meanshift = MeanShift()
cluster = meanshift.fit_predict(mental_health_dataset.drop(['Age'], axis=1))
mental_health_dataset = pd.concat([mental_health_dataset, pd.Series(cluster, name='Cluster_no')], axis=1)
mental_health_dataset.Age = mental_health_true_age

# Filtrar datos por clusters asignados por meanshift
cluster_1 = mental_health_dataset[mental_health_dataset.Cluster_no == 0]
cluster_2 = mental_health_dataset[mental_health_dataset.Cluster_no == 1]


# Display cluster comparison
with pd.option_context('display.max_rows', None, 'display.max_columns', None):
    cluster_compare = pd.concat([cluster_1.mean(), cluster_2.mean()], axis=1)
    cluster_compare.columns = ['0', '1']
    cluster_compare = cluster_compare.drop('Cluster_no')
    for index, row in cluster_compare.iterrows():
        if index != "Age":
            row['0'] = row['0'] * 100
            row['1'] = row['1'] * 100
    cluster_compare['Diff'] = (cluster_compare['0'] - cluster_compare['1'])
    cluster_compare['Abs Diff'] = np.abs(cluster_compare['0'] - cluster_compare['1'])
    cluster_compare = cluster_compare.sort_values(by='Abs Diff', ascending=False)
    print(cluster_compare)

# Plot clusters using PCA
reduced_data = PCA(n_components=2).fit_transform(mental_health_dataset.drop(['Age'], axis=1))
results = pd.DataFrame(reduced_data, columns=['pca1', 'pca2'])

plt.figure(figsize=(10, 4))
sns.scatterplot(x="pca1", y="pca2", hue=mental_health_dataset['Cluster_no'], data=results)
plt.title("Employee's workspace Mental Health Attitude clustering")
plt.show()

"""no pot separar en clusters"""

